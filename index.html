
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ë¨¹ìœ¼ëŸ°(Eat-Run) | GPS ëŸ¬ë‹ ì§€ë„</title>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet Routing Machine (ì¶”ì²œ ë£¨íŠ¸/í™”ì‚´í‘œ ë¼ì¸) -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css" />
  <script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
<style>

:root{
  --bg:#f6f7fb;
  --panel:#ffffff;
  --panel2:#f2f4f8;
  --line:rgba(15,23,42,.10);
  --text:#0b1220;
  --muted:rgba(15,23,42,.60);
  --brand:#03C75A;          /* ë„¤ì´ë²„ ê·¸ë¦° ëŠë‚Œ */
  --brand2:#00A3FF;
  --danger:#ff3355;
  --warn:#ffb020;
  --shadow: 0 12px 35px rgba(15,23,42,.10);
  --r:18px;
  --r2:14px;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", Arial, sans-serif;
  background:var(--bg);
  color:var(--text);
  overflow:hidden;
}

a{color:inherit;text-decoration:none}

.app{
  height:100%;
  display:grid;
  grid-template-rows: 64px 1fr;
}

.topbar{
  position:relative;
  z-index:50;
  background:rgba(255,255,255,.92);
  backdrop-filter: blur(10px);
  border-bottom:1px solid var(--line);
  display:flex;
  align-items:center;
  padding:10px 14px;
  gap:12px;
}
.brand{
  display:flex; align-items:center; gap:10px;
  padding:10px 12px;
  border-radius:999px;
  background:linear-gradient(180deg, rgba(3,199,90,.10), rgba(3,199,90,.06));
  border:1px solid rgba(3,199,90,.22);
  font-weight:900;
  letter-spacing:-.2px;
  white-space:nowrap;
}
.brand .dot{
  width:10px;height:10px;border-radius:999px;background:var(--brand);
  box-shadow:0 0 0 4px rgba(3,199,90,.15);
}

.search{
  flex:1;
  display:flex;
  align-items:center;
  gap:10px;
  background:var(--panel);
  border:1px solid var(--line);
  border-radius:999px;
  padding:10px 12px;
  box-shadow: 0 10px 30px rgba(15,23,42,.06);
  max-width: 740px;
}
.search input{
  border:none; outline:none;
  flex:1;
  font-size:14px;
  background:transparent;
}
.chip{
  font-size:12px;
  color:var(--muted);
  padding:7px 10px;
  border:1px solid var(--line);
  border-radius:999px;
  background:rgba(255,255,255,.7);
  user-select:none;
}
.chip.on{
  color:var(--text);
  border-color: rgba(3,199,90,.35);
  box-shadow: 0 0 0 3px rgba(3,199,90,.10) inset;
}

.actions{display:flex; align-items:center; gap:8px;}
.btn{
  border:1px solid var(--line);
  background:var(--panel);
  color:var(--text);
  padding:10px 12px;
  border-radius:12px;
  font-weight:850;
  cursor:pointer;
  transition: transform .12s ease, box-shadow .12s ease;
}
.btn:hover{transform:translateY(-1px); box-shadow: 0 12px 26px rgba(15,23,42,.10);}
.btn.primary{
  border-color: rgba(3,199,90,.35);
  background: linear-gradient(180deg, rgba(3,199,90,.12), rgba(3,199,90,.06));
}
.btn.danger{
  border-color: rgba(255,51,85,.25);
  background: linear-gradient(180deg, rgba(255,51,85,.12), rgba(255,51,85,.06));
}
.btn:disabled{opacity:.55; cursor:not-allowed; transform:none; box-shadow:none;}

.main{
  height:100%;
  display:grid;
  grid-template-columns: 380px 1fr;
}
@media (max-width: 980px){
  body{overflow:auto}
  .main{grid-template-columns: 1fr; grid-template-rows: 360px 1fr;}
}

.sidebar{
  height:100%;
  background:rgba(255,255,255,.92);
  backdrop-filter: blur(10px);
  border-right:1px solid var(--line);
  box-shadow: 14px 0 40px rgba(15,23,42,.06);
  display:flex;
  flex-direction:column;
  overflow:hidden;
}

.sidebar-header{
  padding:14px 14px 10px;
}
.h1{
  font-weight:950;
  letter-spacing:-.4px;
  font-size:16px;
}
.sub{
  margin-top:6px;
  color:var(--muted);
  font-size:12.5px;
  line-height:1.55;
}
.levels{
  display:flex; gap:8px; flex-wrap:wrap;
  margin-top:10px;
}
.level{
  padding:9px 10px;
  border-radius:14px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.75);
  cursor:pointer;
  user-select:none;
  min-width: 110px;
}
.level .t{font-weight:950; font-size:13px;}
.level .m{font-size:12px; color:var(--muted); margin-top:3px;}
.level.on{
  border-color: rgba(3,199,90,.35);
  box-shadow: 0 0 0 3px rgba(3,199,90,.10) inset;
}

.list{
  padding:8px 10px 14px;
  overflow:auto;
}
.card{
  border:1px solid var(--line);
  border-radius:var(--r);
  background:var(--panel);
  padding:12px 12px;
  margin:10px 4px;
  box-shadow: var(--shadow);
  cursor:pointer;
  transition: transform .12s ease;
}
.card:hover{transform:translateY(-1px);}
.card.on{
  border-color: rgba(0,163,255,.35);
  box-shadow: 0 0 0 3px rgba(0,163,255,.10) inset, var(--shadow);
}
.card .title{font-weight:950; letter-spacing:-.2px;}
.card .meta{margin-top:6px; color:var(--muted); font-size:12px; line-height:1.55;}

.mapWrap{position:relative; height:100%;}
#map{height:100%; width:100%;}

.floating{
  position:absolute;
  right:14px;
  top:14px;
  z-index:1000;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.fab{
  width:46px; height:46px;
  border-radius:16px;
  border:1px solid var(--line);
  background:rgba(255,255,255,.92);
  backdrop-filter: blur(10px);
  box-shadow: var(--shadow);
  display:flex; align-items:center; justify-content:center;
  cursor:pointer;
  user-select:none;
  font-size:18px;
}
.fab:hover{transform:translateY(-1px);}

.runSheet{
  position:absolute;
  left:50%;
  transform: translateX(-50%);
  bottom:14px;
  z-index:1000;
  width:min(860px, calc(100% - 28px));
  border-radius: 22px;
  border:1px solid var(--line);
  background: rgba(255,255,255,.92);
  backdrop-filter: blur(12px);
  box-shadow: 0 20px 60px rgba(15,23,42,.16);
  overflow:hidden;
}
.runSheet .bar{
  display:flex; align-items:center; justify-content:space-between;
  padding:12px 14px;
  border-bottom:1px solid var(--line);
}
.badge{
  display:inline-flex; align-items:center; gap:8px;
  padding:8px 10px;
  border-radius:999px;
  background: rgba(3,199,90,.10);
  border:1px solid rgba(3,199,90,.22);
  font-weight:950;
  font-size:12.5px;
}
.badge .dot{
  width:8px;height:8px;border-radius:999px;background:var(--brand);
  box-shadow:0 0 0 4px rgba(3,199,90,.14);
}
.kpis{
  padding:12px 14px 14px;
  display:grid;
  grid-template-columns: repeat(4, 1fr);
  gap:10px;
}
@media(max-width:980px){ .kpis{grid-template-columns: repeat(2,1fr);} }
.kpi{
  border:1px solid var(--line);
  background: rgba(255,255,255,.75);
  border-radius: 16px;
  padding:10px;
}
.kpi .l{font-size:12px; color:var(--muted); font-weight:800;}
.kpi .v{font-size:20px; font-weight:1000; letter-spacing:-.3px; margin-top:6px;}
.kpi .s{font-size:12px; color:var(--muted); margin-top:4px;}

.toast{
  position:absolute;
  left:14px;
  bottom:14px;
  z-index:1200;
  width:320px;
  border-radius: 18px;
  border:1px solid var(--line);
  background: rgba(15,23,42,.92);
  color: white;
  box-shadow: 0 18px 50px rgba(0,0,0,.25);
  padding:12px 12px;
  display:none;
}
.toast.show{display:block}
.toast .t{font-weight:950}
.toast .m{margin-top:6px; opacity:.86; font-size:13px; line-height:1.45;}

.smallNote{
  font-size:12px;
  color:var(--muted);
  padding: 0 14px 14px;
}


/* Route summary overlay box (mid-route) */
.routeSummaryBox{
  background: rgba(255,255,255,.92);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(15,23,42,.14);
  border-radius: 14px;
  box-shadow: 0 18px 50px rgba(15,23,42,.18);
  padding: 10px 12px;
  min-width: 230px;
  pointer-events: none;
}
.routeSummaryBox .t{font-weight:950; font-size:13px; color:#0b1220;}
.routeSummaryBox .big{font-weight:1000; font-size:18px; margin-top:4px; color:#0b1220;}
.routeSummaryBox .row{display:flex; justify-content:space-between; gap:10px; font-size:12px; color:rgba(15,23,42,.70); margin-top:6px;}
.routeSummaryIcon{pointer-events:none;}


/* --- One-file Mobile polish --- */
:root{ --safe-top: env(safe-area-inset-top); --safe-bot: env(safe-area-inset-bottom); }
html,body{height:100%;}
body{margin:0; -webkit-text-size-adjust:100%;}
/* Ensure map is visible on mobile */
.main{height:100vh; height:100dvh;}
header{padding-top: calc(8px + var(--safe-top));}
/* Make controls tappable */
button, .chip, .level{ touch-action: manipulation; }
#map{min-height: 45vh;}
/* If there is a bottom panel, make it scroll */
.panel, .sidebar, #storeList{ -webkit-overflow-scrolling: touch; }
</style>
</head>
<body>
  <div class="app">
    <!-- Topbar (ë„¤ì´ë²„ ì§€ë„ ëŠë‚Œ: ìƒë‹¨ ê²€ìƒ‰ + ì¹©) -->
    <div class="topbar">
      <div class="brand">
        <span class="dot"></span>
        <span>ë¨¹ìœ¼ëŸ° GPS</span>
      </div>

      <div class="search" title="ë§¤ì¥/ì§€ì—­ ê²€ìƒ‰">
        <span style="opacity:.65">ğŸ”</span>
        <input id="searchInput" placeholder="ì–´ë””ê¹Œì§€ ë›°ê³ , ë­˜ ë¨¹ì„ê¹Œìš”? (ì˜ˆ: ì—¬ì˜ë„ / ì¹˜í‚¨ / ì„±ìˆ˜)" />
        <span class="chip" id="chipLv1">LV1</span>
        <span class="chip" id="chipLv2">LV2</span>
        <span class="chip" id="chipLv3">LV3</span>
        <span class="chip" id="chipPoi" title="ì¹´ì¹´ì˜¤ ë¡œì»¬ APIë¡œ ì£¼ë³€ ì‹ë‹¹ í‘œì‹œ">ğŸ´ ì‹ë‹¹</span>
      </div>

      <div class="actions">
        <button class="btn" id="btnReRoute" title="í˜„ì¬ ìœ„ì¹˜ â†’ ëª©ì ì§€ ë£¨íŠ¸ ê°±ì‹ ">ğŸ§­ ë£¨íŠ¸</button>
        <button class="btn primary" id="toggleFollow" data-on="1" title="ë‚´ ìœ„ì¹˜ë¥¼ í™”ë©´ì´ ë”°ë¼ì˜µë‹ˆë‹¤">ğŸ‘ï¸ ë”°ë¼ê°€ê¸° ON</button>
      </div>
    </div>

    <div class="main">
      <!-- Sidebar (ì—„ë§ˆì˜ ì§€ë„ ëŠë‚Œ: ì¹´ë“œí˜• íë ˆì´ì…˜ ë¦¬ìŠ¤íŠ¸) -->
      <aside class="sidebar">
        <div class="sidebar-header">
          <div class="h1">ì˜¤ëŠ˜ì˜ ë„ì°©ì (Goal)</div>
          <div class="sub">
            ëª©ì ì§€ë¥¼ ì„ íƒí•˜ë©´ ì¶”ì²œ ë£¨íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤. <br/>
            ëŸ¬ë‹ì„ ì‹œì‘í•˜ë©´ ì´ˆë¡ ë¼ì¸ìœ¼ë¡œ ì‹¤ì‹œê°„ íŠ¸ë™ì´ ê·¸ë ¤ì§‘ë‹ˆë‹¤.
          </div>

          <div class="levels" id="levels"></div>

          <div style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap;">
            <span class="chip on" id="levelBadge">LV.1</span>
            <span class="chip" id="goalBadge">ëª©ì ì§€</span>
          </div>
        </div>

        <div class="list" id="storeList"></div>
      </aside>

      <!-- Map -->
      <section class="mapWrap">
        <div id="map"></div>

        <div class="floating">
          <div class="fab" id="fabLocate" title="ë‚´ ìœ„ì¹˜">ğŸ“</div>
          <div class="fab" id="fabGoal" title="ëª©ì ì§€ ë³´ê¸°">ğŸ¯</div>
          <div class="fab" id="fabClear" title="íŠ¸ë™ ì´ˆê¸°í™”">ğŸ§¼</div>
        </div>

        <!-- Run sheet (í•˜ë‹¨ ëŸ¬ë‹ ëŒ€ì‹œë³´ë“œ) -->
        <div class="runSheet">
          <div class="bar">
            <div class="badge"><span class="dot"></span><span id="kpiState">ëŒ€ê¸°</span></div>
            <div style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
              <span class="chip">ì¶”ì²œ ë£¨íŠ¸: <b id="kpiRoute">â€”</b></span>
              <span class="chip">ëª©í‘œ: <b id="kpiGoal">â€”</b></span>
              <span class="chip">ì§„í–‰: <b id="kpiProgress">0%</b></span>
            </div>
            <div style="display:flex; gap:8px;">
              <button class="btn primary" id="btnStart">ëŸ¬ë‹ ì‹œì‘</button>
              <button class="btn" id="btnPause" disabled>ì¼ì‹œì •ì§€</button>
              <button class="btn danger" id="btnStop" disabled>ì¢…ë£Œ</button>
            </div>
          </div>

          <div class="kpis">
            <div class="kpi">
              <div class="l">ê±°ë¦¬</div>
              <div class="v" id="kpiDist">0.00 km</div>
              <div class="s">ì´ˆë¡ ë¼ì¸ì´ ì‹¤ì œ íŠ¸ë™</div>
            </div>
            <div class="kpi">
              <div class="l">ì‹œê°„</div>
              <div class="v" id="kpiTime">0:00</div>
              <div class="s">ì¼ì‹œì •ì§€ ì‹œ ì •ì§€</div>
            </div>
            <div class="kpi">
              <div class="l">í˜ì´ìŠ¤</div>
              <div class="v" id="kpiPace">--</div>
              <div class="s">í‰ê·  í˜ì´ìŠ¤</div>
            </div>
            <div class="kpi">
              <div class="l">GPS</div>
              <div class="v"><span id="kpiAcc">--</span></div>
              <div class="s">ì†ë„: <span id="kpiSpeed">--</span></div>
            </div>
          </div>

          <div class="smallNote">
            â€¢ ìœ„ì¹˜ ê¸°ëŠ¥ì€ <b>https</b> ë˜ëŠ” <b>http://localhost</b>ì—ì„œë§Œ ë™ì‘í•©ë‹ˆë‹¤. <br/>
            â€¢ MVP ë¶€ì •ë°©ì§€: 25km/h ì´ìƒìœ¼ë¡œ ì´ë™í•œ êµ¬ê°„ì€ ê±°ë¦¬ì—ì„œ ì œì™¸ë©ë‹ˆë‹¤.
            â€¢ ì£¼ë³€ ì‹ë‹¹(POI) ë°ì´í„°ëŠ” ì¹´ì¹´ì˜¤ ë¡œì»¬ API ê²€ìƒ‰ ê²°ê³¼ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
          </div>
        </div>

        <div class="toast" id="toast">
          <div class="t" id="toastTitle"></div>
          <div class="m" id="toastMsg"></div>
        </div>
      </section>
    </div>
  </div>

  <script>
/* --- One-file guard --- */
window.addEventListener('error', (e)=>{
  try{
    const el = document.createElement('div');
    el.style.position='fixed'; el.style.left='12px'; el.style.right='12px';
    el.style.bottom='12px'; el.style.zIndex=99999;
    el.style.padding='10px 12px'; el.style.borderRadius='14px';
    el.style.background='rgba(0,0,0,.75)'; el.style.color='white';
    el.style.fontSize='12px';
    el.textContent = 'ì˜¤ë¥˜: ' + (e?.message||'ìŠ¤í¬ë¦½íŠ¸ ì˜¤ë¥˜') + ' (ëª¨ë°”ì¼ì—ì„œ ì™¸ë¶€ ë¦¬ì†ŒìŠ¤ê°€ ì°¨ë‹¨ë˜ë©´ ì§€ë„/ë£¨íŒ…ì´ ì•ˆ ë³´ì¼ ìˆ˜ ìˆì–´ìš”)';
    document.body.appendChild(el);
    setTimeout(()=>{ try{el.remove();}catch(_){} }, 6000);
  }catch(_){}
});


/**
 * Eat-Run (GPS-first) PC Web MVP
 * - Single-page UI (Naver-map style top search + left panel + full map)
 * - Leaflet map + Routing (OSRM via Leaflet Routing Machine)
 * - Live GPS tracking: polyline, distance, time, pace, speed, accuracy
 * - Gamified levels (lv1/2/3)
 *
 * Notes:
 * - Geolocation works only on https or http://localhost.
 * - Routing uses public OSRM demo server by default; for production, host your own OSRM.
 */

const LEVELS = {
  lv1: { name: "LV.1 (3~5km)", min: 3, max: 5, rewardHint: "ìŒë£Œ/ì£¼ë¥˜ 1ì” ë¬´ë£Œ" },
  lv2: { name: "LV.2 (7~10km)", min: 7, max: 10, rewardHint: "ì‚¬ì´ë“œ 1ê°œ ë¬´ë£Œ" },
  lv3: { name: "LV.3 (15km+)", min: 15, max: 20, rewardHint: "10~20% í• ì¸/ì‚¬ì´ì¦ˆì—…" },
};

// Sample stores (ì„œìš¸ ëŸ¬ë‹ ê±°ì : ë°˜í¬/ì—¬ì˜ë„/ì„±ìˆ˜)
const STORES = [
  {
    "id": "sangam_dorak",
    "name": "ë„ë½",
    "area": "ìƒì•”ë™",
    "category": "í•œì‹",
    "lat": 37.5797,
    "lng": 126.8896,
    "desc": "ìƒì•” DMC ëŸ¬ë‹ í›„ ë“ ë“ í•œ í•œì‹ ë³´ìƒ."
  },
  {
    "id": "sangam_hoegwan",
    "name": "ìƒì•”íšŒê´€",
    "area": "ìƒì•”ë™",
    "category": "ê³ ê¸°",
    "lat": 37.5789,
    "lng": 126.8909,
    "desc": "ì¥ê±°ë¦¬ ëŸ¬ë‹ í›„ ê³ ê¸° íšŒì‹ ëª…ì†Œ."
  },
  {
    "id": "banghwa_blackradio",
    "name": "ë¸”ë™ë¼ë””ì˜¤",
    "area": "ë°©í™”ë™",
    "category": "ì¹´í˜",
    "lat": 37.5734,
    "lng": 126.8126,
    "desc": "ë°©í™”Â·ë§ˆê³¡ ëŸ¬ë‹ í›„ ì»¤í”¼ í•œ ì”."
  },
  {
    "id": "itaewon_vatos",
    "name": "ë°”í† ìŠ¤ ì´íƒœì›",
    "area": "ì´íƒœì›",
    "category": "ë©•ì‹œì¹¸",
    "lat": 37.5345,
    "lng": 126.9946,
    "desc": "ëŸ¬ë‹ í›„ íƒ„ë‹¨ì§€ ë°¸ëŸ°ìŠ¤ íƒ€ì½”."
  },
  {
    "id": "hongdae_choigori",
    "name": "ìµœê³ ì§‘ í™ëŒ€",
    "area": "í™ëŒ€",
    "category": "ê³ ê¸°",
    "lat": 37.5561,
    "lng": 126.9228,
    "desc": "ì Šì€ ëŸ¬ë‹ í¬ë£¨ ë’¤í’€ì´ ë‹¨ê³¨."
  },
  {
    "id": "yeonnam_tofu",
    "name": "ì—°ë‚¨ë‘ë¶€",
    "area": "ì—°ë‚¨ë™",
    "category": "í•œì‹",
    "lat": 37.5664,
    "lng": 126.9221,
    "desc": "ë‹´ë°±í•œ ë‹¨ë°±ì§ˆ ë³´ì¶©."
  },
  {
    "id": "gangnam_hadongkwan",
    "name": "í•˜ë™ê´€ ê°•ë‚¨",
    "area": "ê°•ë‚¨",
    "category": "ê³°íƒ•",
    "lat": 37.4989,
    "lng": 127.0276,
    "desc": "ì¥ê±°ë¦¬ í›„ êµ­ë¬¼ ì›íƒ‘."
  },
  {
    "id": "eulji_pyeongrae",
    "name": "í‰ë˜ì˜¥",
    "area": "ì„ì§€ë¡œ",
    "category": "ëƒ‰ë©´",
    "lat": 37.5656,
    "lng": 126.9909,
    "desc": "ì„œìš¸ ëƒ‰ë©´ ì„±ì§€."
  },
  {
    "id": "jongno_gwangjang",
    "name": "ê´‘ì¥ì‹œì¥ ë¹ˆëŒ€ë–¡",
    "area": "ì¢…ë¡œ",
    "category": "ë¶„ì‹",
    "lat": 37.57,
    "lng": 126.9996,
    "desc": "ëŸ¬ë‹ í›„ ê°€ë²¼ìš´ íƒ„ìˆ˜í™”ë¬¼."
  },
  {
    "id": "seongsu_jayeondo",
    "name": "ìì—°ë„ì†Œê¸ˆë¹µ ì„±ìˆ˜",
    "area": "ì„±ìˆ˜",
    "category": "ë² ì´ì»¤ë¦¬",
    "lat": 37.5446,
    "lng": 127.0557,
    "desc": "ëŸ¬ë‹ ë°ì´íŠ¸ ë³´ìƒìš©."
  },
  {
    "id": "apgujeong_gukbap",
    "name": "ì••êµ¬ì • í˜„ëŒ€êµ­ë°¥",
    "area": "ì••êµ¬ì •",
    "category": "êµ­ë°¥",
    "lat": 37.5271,
    "lng": 127.0289,
    "desc": "ë“ ë“ í•œ íšŒë³µì‹."
  },
  {
    "id": "jamsil_chamsut",
    "name": "ì°¸ìˆ¯ë¶ˆê°ˆë¹„ ì ì‹¤",
    "area": "ì ì‹¤",
    "category": "ê³ ê¸°",
    "lat": 37.5118,
    "lng": 127.098,
    "desc": "ì„ì´Œí˜¸ìˆ˜ ëŸ¬ë‹ ë’¤ íšŒì‹."
  },
  {
    "id": "sinsa_mosus",
    "name": "ëª¨ìˆ˜ ì„œìš¸",
    "area": "ì‹ ì‚¬",
    "category": "íŒŒì¸ë‹¤ì´ë‹",
    "lat": 37.5253,
    "lng": 127.0344,
    "desc": "20km ì™„ì£¼ì VIP ì½”ìŠ¤."
  },
  {
    "id": "mapo_gyedong",
    "name": "ê³„ë™ì¹˜í‚¨ ë§ˆí¬",
    "area": "ë§ˆí¬",
    "category": "ì¹˜í‚¨",
    "lat": 37.5412,
    "lng": 126.946,
    "desc": "í•œê°• ëŸ¬ë‹ í›„ ì¹˜ë§¥."
  },
  {
    "id": "dongdaemun_jinok",
    "name": "ì§„ì˜¥í™”í• ë§¤ë‹­í•œë§ˆë¦¬",
    "area": "ë™ëŒ€ë¬¸",
    "category": "ë‹­",
    "lat": 37.5706,
    "lng": 127.0076,
    "desc": "íšŒë³µì— ì¢‹ì€ ë”°ëœ»í•œ ë‹­ìš”ë¦¬."
  },
  {
    "id": "gwanghwamun_tosok",
    "name": "í† ì†ì´Œ ì‚¼ê³„íƒ•",
    "area": "ê´‘í™”ë¬¸",
    "category": "ì‚¼ê³„íƒ•",
    "lat": 37.5764,
    "lng": 126.9736,
    "desc": "ë©´ì—­ë ¥ íšŒë³µ ë³´ìƒ."
  },
  {
    "id": "yeouido_63buffet",
    "name": "63ë¹Œë”© íŒŒë¹Œë¦¬ì˜¨",
    "area": "ì—¬ì˜ë„",
    "category": "ë·”í˜",
    "lat": 37.5194,
    "lng": 126.9408,
    "desc": "ì¥ê±°ë¦¬ ëŸ¬ë‹ í›„ ì˜¬ì¸ì› ë³´ìƒ."
  },
  {
    "id": "suyu_galbi",
    "name": "ìˆ˜ìœ  ë¼ì§€ê°ˆë¹„",
    "area": "ìˆ˜ìœ ",
    "category": "ê³ ê¸°",
    "lat": 37.6384,
    "lng": 127.0255,
    "desc": "ë¶ë¶€ ëŸ¬ë‹ í¬ë£¨ ì„±ì§€."
  },
  {
    "id": "cheonho_sushi",
    "name": "ì²œí˜¸ ìŠ¤ì‹œíš¨",
    "area": "ì²œí˜¸",
    "category": "ìŠ¤ì‹œ",
    "lat": 37.5381,
    "lng": 127.125,
    "desc": "ê³ ê¸‰ ë‹¨ë°±ì§ˆ ë³´ìƒ."
  },
  {
    "id": "yeoksam_pasta",
    "name": "ì—­ì‚¼ íŒŒìŠ¤íƒ€ì§‘",
    "area": "ì—­ì‚¼",
    "category": "ì–‘ì‹",
    "lat": 37.5003,
    "lng": 127.0365,
    "desc": "ëŸ¬ë‹ ë°ì´íŠ¸ ì½”ìŠ¤."
  },
  {
    "id": "sadang_gopchang",
    "name": "ì‚¬ë‹¹ ê³±ì°½ì§‘",
    "area": "ì‚¬ë‹¹",
    "category": "ê³±ì°½",
    "lat": 37.4765,
    "lng": 126.9816,
    "desc": "ì¥ê±°ë¦¬ í›„ ê³ ì§€ë°© ë³´ìƒ."
  },
  {
    "id": "cheongdam_bbq",
    "name": "ì²­ë‹´ ë°”ë¹„í",
    "area": "ì²­ë‹´",
    "category": "ë°”ë¹„í",
    "lat": 37.5242,
    "lng": 127.0476,
    "desc": "í”„ë¦¬ë¯¸ì—„ íšŒë³µì‹."
  },
  {
    "id": "eunpyeong_cafe",
    "name": "ì€í‰ í•œì˜¥ì¹´í˜",
    "area": "ì€í‰",
    "category": "ì¹´í˜",
    "lat": 37.639,
    "lng": 126.9395,
    "desc": "ëŸ¬ë‹ í›„ íë§."
  }
];




// ------- Helpers -------
const $ = (sel) => document.querySelector(sel);
const $$ = (sel) => [...document.querySelectorAll(sel)];

function toast(title, msg) {
  const el = $("#toast");
  $("#toastTitle").textContent = title;
  $("#toastMsg").textContent = msg;
  el.classList.add("show");
  setTimeout(() => el.classList.remove("show"), 3200);
}

function pad2(n) {
  return String(n).padStart(2, "0");
}
function formatTime(sec) {
  const m = Math.floor(sec / 60);
  const s = Math.floor(sec % 60);
  return `${m}:${pad2(s)}`;
}
function formatKm(n) {
  return (Math.round(n * 100) / 100).toFixed(2);
}
function pace(sec, km) {
  if (!km || km < 0.01) return "--";
  const spk = sec / km;
  const m = Math.floor(spk / 60);
  const s = Math.floor(spk % 60);
  return `${m}:${pad2(s)}/km`;
}
function haversine(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const toRad = (d) => (d * Math.PI) / 180;
  const Ï†1 = toRad(lat1), Ï†2 = toRad(lat2);
  const Î”Ï† = toRad(lat2 - lat1);
  const Î”Î» = toRad(lon2 - lon1);
  const a =
    Math.sin(Î”Ï† / 2) ** 2 +
    Math.cos(Ï†1) * Math.cos(Ï†2) * Math.sin(Î”Î» / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

function destinationPoint(lat, lng, bearingDeg, distanceM){
  const R = 6371000;
  const br = bearingDeg * Math.PI/180;
  const Ï†1 = lat * Math.PI/180;
  const Î»1 = lng * Math.PI/180;
  const Î´ = distanceM / R;
  const Ï†2 = Math.asin(Math.sin(Ï†1)*Math.cos(Î´) + Math.cos(Ï†1)*Math.sin(Î´)*Math.cos(br));
  const Î»2 = Î»1 + Math.atan2(Math.sin(br)*Math.sin(Î´)*Math.cos(Ï†1), Math.cos(Î´)-Math.sin(Ï†1)*Math.sin(Ï†2));
  return { lat: (Ï†2*180/Math.PI), lng: (Î»2*180/Math.PI) };
}
function withTimeout(p, ms=3500){
  return Promise.race([p, new Promise((_,rej)=>setTimeout(()=>rej(new Error("timeout")), ms))]);
}
function polylineMeters(coords){
  let m=0;
  for(let i=1;i<coords.length;i++){
    const a=coords[i-1], b=coords[i];
    const alat = a.lat ?? a[0], alng = a.lng ?? a[1];
    const blat = b.lat ?? b[0], blng = b.lng ?? b[1];
    m += haversine(alat, alng, blat, blng);
  }
  return m;
}
function sampleAlong(coords, n=16){
  if (!coords || coords.length<2) return [];
  const pts = coords.map(c=>({lat:c.lat??c[0], lng:c.lng??c[1]}));
  const total = polylineMeters(pts);
  if (!total) return [pts[0], pts[pts.length-1]];
  const step = total/(n-1);
  const out=[pts[0]];
  let acc=0, target=step;
  for(let i=1;i<pts.length;i++){
    let seg = haversine(pts[i-1].lat, pts[i-1].lng, pts[i].lat, pts[i].lng);
    while(acc + seg >= target && out.length < n-1){
      const t = (target-acc)/(seg||1);
      out.push({lat: pts[i-1].lat + (pts[i].lat-pts[i-1].lat)*t, lng: pts[i-1].lng + (pts[i].lng-pts[i-1].lng)*t});
      target += step;
    }
    acc += seg;
  }
  out.push(pts[pts.length-1]);
  return out.slice(0,n);
}
async function fetchElevations(points){
  const loc = points.map(p=>`${p.lat},${p.lng}`).join("|");
  const url = `https://api.opentopodata.org/v1/srtm90m?locations=${encodeURIComponent(loc)}`;
  const j = await withTimeout(fetch(url).then(r=>r.json()), 4500);
  const arr = j?.results?.map(x=>x.elevation);
  if (!arr || arr.length < 2) throw new Error("no_elev");
  return arr;
}
async function countCrossings(coords){
  const pts = coords.map(c=>({lat:c.lat??c[0], lng:c.lng??c[1]}));
  let minLat=90, maxLat=-90, minLng=180, maxLng=-180;
  pts.forEach(p=>{minLat=Math.min(minLat,p.lat); maxLat=Math.max(maxLat,p.lat); minLng=Math.min(minLng,p.lng); maxLng=Math.max(maxLng,p.lng);});
  const pad=0.01;
  minLat-=pad; maxLat+=pad; minLng-=pad; maxLng+=pad;
  const q = `[out:json][timeout:6];(node["highway"="crossing"](${minLat},${minLng},${maxLat},${maxLng}););out count;`;
  const url = "https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(q);
  const j = await withTimeout(fetch(url).then(r=>r.json()), 6500);
  const el = j?.elements?.[0];
  const total = Number(el?.tags?.total ?? j?.elements?.length ?? 0);
  return isFinite(total) ? total : 0;
}
async function computeRouteStats(coords){
  const pts = coords.map(c=>({lat:c.lat??c[0], lng:c.lng??c[1]}));
  const distM = polylineMeters(pts);
  const sample = sampleAlong(pts, 16);
  let gain=null, loss=null, avgSlope=null;
  try{
    const elev = await fetchElevations(sample);
    let g=0,l=0;
    for(let i=1;i<elev.length;i++){
      const d=elev[i]-elev[i-1];
      if (d>0) g+=d; else l+=(-d);
    }
    gain=Math.round(g); loss=Math.round(l);
    avgSlope = (g/(distM||1))*100;
  }catch(e){}
  let crossings=null;
  try{ crossings = await countCrossings(pts); }catch(e){}
  return { distKm: distM/1000, gainM: gain, lossM: loss, avgSlope, crossings };
}
let routeSummaryMarker = null;
function clearRouteSummaryBox(){
  if (routeSummaryMarker){ try{ map.removeLayer(routeSummaryMarker);}catch(e){} routeSummaryMarker=null; }
}
function showRouteSummaryBox(coords, stats){
  if (!coords || coords.length<2) return;
  const mid = coords[Math.floor(coords.length/2)];
  const lat = mid.lat ?? mid[0], lng = mid.lng ?? mid[1];
  const distText = stats?.distKm ? `${stats.distKm.toFixed(1)} km` : "â€”";
  const slopeText = (stats?.avgSlope!=null) ? `${stats.avgSlope.toFixed(1)}%` : "â€”";
  const crossText = (stats?.crossings!=null) ? `${stats.crossings}ê°œ` : "â€”";
  const gainText = (stats?.gainM!=null && stats?.lossM!=null) ? `+${stats.gainM} / -${stats.lossM}m` : "â€”";
  const boxHtml = `<div class="routeSummaryBox">
    <div class="t">ğŸ“Œ ë£¨íŠ¸ ìš”ì•½</div>
    <div class="big">${distText}</div>
    <div class="row"><span>í‰ê·  ê²½ì‚¬</span><b>${slopeText}</b></div>
    <div class="row"><span>ê±´ë„ëª© ìˆ˜</span><b>${crossText}</b></div>
    <div class="row"><span>ìƒìŠ¹/í•˜ê°•</span><b>${gainText}</b></div>
  </div>`;
  const icon = L.divIcon({ className:"routeSummaryIcon", html: boxHtml, iconSize:[260,1], iconAnchor:[130,0] });
  clearRouteSummaryBox();
  routeSummaryMarker = L.marker([lat,lng], { icon, interactive:false, keyboard:false, zIndexOffset:900 }).addTo(map);
}



// ------- State -------
let selectedLevel = "lv1";
let desiredKm = 5; // lv1=5, lv2=10, lv3=20
let detourScale = 1.0; // auto-tuned so OSRM distance matches selected km
let lastRouteTry = 0;
function levelToKm(lv){ return (lv==="lv3")?20:(lv==="lv2")?10:5; }
function kmToLevel(km){ return (km>=20)?"lv3":(km>=10)?"lv2":"lv1"; }
let selectedStoreId = STORES[0].id;

let map, userMarker, goalMarker, routeControl;
let storeMarkers = new Map();

let poiLayer = null;
let poiMarkers = [];
let poiOn = false;
let poiQuery = ""; // if user types food keyword, we can reuse search input optionally

let tracking = false;
let paused = false;
let watchId = null;
let timerId = null;
let startTs = null;
let elapsedSec = 0;

let lastFix = null;      // {lat,lng,ts,acc}
let distanceM = 0;
let trackLine = null;
let trackLatLngs = [];

const SPEED_CHEAT_KMH = 25;  // MVP ìˆ˜ì¤€ì˜ ê°„ë‹¨í•œ ë¶€ì • ë°©ì§€
const JITTER_M = 3;

function currentStore() {
  return STORES.find((s) => s.id === selectedStoreId) || STORES[0];
}

// ------- UI render -------
function renderLevels() {
  const wrap = $("#levels");
  wrap.innerHTML = Object.entries(LEVELS)
    .map(([k, v]) => {
      const on = k === selectedLevel ? "on" : "";
      return `
      <div class="level ${on}" data-level="${k}">
        <div class="t">${v.name}</div>
        <div class="m">${v.rewardHint}</div>
      </div>`;
    })
    .join("");

  $$("#levels .level").forEach((el) => {
    el.addEventListener("click", () => {
      if (el.classList.contains("disabled")) return;
      selectedLevel = el.dataset.level;
      desiredKm = levelToKm(selectedLevel);
      detourScale = 1.0;
      $$("#levels .level").forEach((x) => x.classList.remove("on"));
      el.classList.add("on");
      $("#chipLv1").classList.toggle("on", selectedLevel === "lv1");
      $("#chipLv2").classList.toggle("on", selectedLevel === "lv2");
      $("#chipLv3").classList.toggle("on", selectedLevel === "lv3");
      updateHeaderBadges();
      if (tracking) toast("ì½”ìŠ¤ ë³€ê²½", "ëŸ¬ë‹ ì¤‘ì—ëŠ” ê¶Œì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì¢…ë£Œ í›„ ë‹¤ì‹œ ì‹œì‘í•´ì£¼ì„¸ìš”.");
    });
  });
}

function renderStoreList(list = STORES) {
  const el = $("#storeList");
  el.innerHTML = list
    .map((s) => {
      const on = s.id === selectedStoreId ? "on" : "";
      const tagStr = s.tags?.slice(0, 3).map((t) => `#${t}`).join(" ");
      return `
      <div class="card ${on}" data-store="${s.id}">
        <div class="title">${s.name}</div>
        <div class="meta">ğŸ“ ${s.area} Â· ${s.category}<br>${s.desc}</div>
        <div class="meta" style="margin-top:8px;color:rgba(15,23,42,.50)">${tagStr || ""}</div>
      </div>`;
    })
    .join("");

  $$("#storeList .card").forEach((c) => {
    c.addEventListener("click", () => {
      selectedStoreId = c.dataset.store;
      $$("#storeList .card").forEach((x) => x.classList.remove("on"));
      c.classList.add("on");
      focusGoal();
      buildRoute(); // update route
      updateHeaderBadges();
    });
  });
}

function updateHeaderBadges() {
  const s = currentStore();
  $("#goalBadge").textContent = `ëª©ì ì§€: ${s.name}`;
  $("#levelBadge").textContent = `${LEVELS[selectedLevel].name}`;
}

function bindTopChips() {
  $("#chipLv1").addEventListener("click", () => setLevelChip("lv1"));
  $("#chipLv2").addEventListener("click", () => setLevelChip("lv2"));
  $("#chipLv3").addEventListener("click", () => setLevelChip("lv3"));
  $("#chipPoi").addEventListener("click", togglePOI);

  function setLevelChip(level) {
    selectedLevel = level;
    $("#chipLv1").classList.toggle("on", level === "lv1");
    $("#chipLv2").classList.toggle("on", level === "lv2");
    $("#chipLv3").classList.toggle("on", level === "lv3");
    renderLevels();
    updateHeaderBadges();
  }
}

function bindSearch() {
  const input = $("#searchInput");
  input.addEventListener("input", () => {
    const q = input.value.trim().toLowerCase();
    if (!q) return renderStoreList(STORES);
    const filtered = STORES.filter((s) =>
      (s.name + " " + s.area + " " + s.category + " " + (s.tags || []).join(" "))
        .toLowerCase()
        .includes(q)
    );
    renderStoreList(filtered);
  });
}

// ------- Map -------
function initMap() {
  const s = currentStore();
  map = L.map("map", { zoomControl: false }).setView([s.lat, s.lng], 13);

  // OSM base (ê°€ë²¼ìš´ MVP)
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    maxZoom: 19,
    attribution: "&copy; OpenStreetMap",
  }).addTo(map);

  L.control.zoom({ position: "bottomright" }).addTo(map);

  // Store markers
  STORES.forEach((store) => {
    const m = L.marker([store.lat, store.lng]).addTo(map);
    m.bindPopup(`<b>${store.name}</b><br>${store.area} Â· ${store.category}<br>${store.desc}`);
    m.on("click", () => {
      selectedStoreId = store.id;
      renderStoreList(STORES);
      focusGoal();
      buildRoute();
      updateHeaderBadges();
    });
    storeMarkers.set(store.id, m);
  });

  // Goal marker (blue-ish)
  goalMarker = L.circleMarker([s.lat, s.lng], {
    radius: 10,
    color: "#0b1220",
    weight: 2,
    fillColor: "#00A3FF",
    fillOpacity: 0.95,
  }).addTo(map);

  // User marker placeholder (green)
  userMarker = L.circleMarker([s.lat, s.lng], {
    radius: 9,
    color: "#0b1220",
    weight: 2,
    fillColor: "#03C75A",
    fillOpacity: 0.95,
  }).addTo(map);

  // Track polyline
  trackLine = L.polyline([], { color: "#03C75A", weight: 5, opacity: 0.85 }).addTo(map);

  // initial route (best-effort; needs user position)
  buildRoute(true);
}

function focusGoal() {
  const s = currentStore();
  goalMarker.setLatLng([s.lat, s.lng]);
  map.setView([s.lat, s.lng], 14, { animate: true });
  // popup
  const marker = storeMarkers.get(s.id);
  if (marker) marker.openPopup();
}

function updateUserMarker(lat, lng) {
  userMarker.setLatLng([lat, lng]);
}

function buildRoute(initial = false) {
  const s = currentStore();
  if (!s) return;
  goalMarker.setLatLng([s.lat, s.lng]);

  if (routeControl) {
    try { map.removeControl(routeControl); } catch(e){}
    routeControl = null;
  }
  clearRouteSummaryBox();

  const start = lastFix ? L.latLng(lastFix.lat, lastFix.lng) : null;
  const goal = L.latLng(s.lat, s.lng);

  if (!start) {
    if (!initial) toast("ë£¨íŠ¸ ì•ˆë‚´", "ë‚´ ìœ„ì¹˜ ìˆ˜ì‹  í›„ ì¶”ì²œ ë£¨íŠ¸ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.");
    return;
  }

  // Auto change course by distance (cannot be shorter than needed)
  const straightKm = haversine(start.lat, start.lng, goal.lat, goal.lng)/1000;
  const needKm = straightKm * 1.15; // real route tends to be longer than straight line
  if (desiredKm < needKm) {
    const km = (needKm<=5)?5:(needKm<=10)?10:20;
    selectedLevel = kmToLevel(km);
    desiredKm = levelToKm(selectedLevel);
      detourScale = 1.0;
    updateHeaderBadges();
    $("#chipLv1")?.classList.toggle("on", selectedLevel==="lv1");
    $("#chipLv2")?.classList.toggle("on", selectedLevel==="lv2");
    $("#chipLv3")?.classList.toggle("on", selectedLevel==="lv3");
    $$("#levels .level").forEach(x=>x.classList.toggle("on", x.dataset.level===selectedLevel));
    toast("ì½”ìŠ¤ ìë™ ë³€ê²½", `ê±°ë¦¬ ${straightKm.toFixed(1)}km â†’ ${LEVELS[selectedLevel].name}`);
  }

  // If user wants longer than needed, add detour points so route changes by km
  let waypoints = [start, goal];
  if (desiredKm > needKm + 0.25) {
    const extraM = (desiredKm - needKm) * 1000 * detourScale;
    const mid = L.latLng((start.lat + goal.lat)/2, (start.lng + goal.lng)/2);
    const seed = (Math.floor((start.lat+start.lng)*100000) + Math.floor((goal.lat+goal.lng)*100000) + desiredKm*1000) % 360;
    const legM = Math.max(650, extraM/2);
    const p1 = destinationPoint(mid.lat, mid.lng, seed, legM);
    const p2 = destinationPoint(mid.lat, mid.lng, (seed+140)%360, legM);
    waypoints = [start, L.latLng(p1.lat,p1.lng), L.latLng(p2.lat,p2.lng), goal];
  }

  routeControl = L.Routing.control({
    waypoints,
    lineOptions: {
      styles: [{ color: "#00A3FF", opacity: 0.8, weight: 6 }],
      addWaypoints: false,
      extendToWaypoints: true,
      missingRouteTolerance: 10,
    },
    router: L.Routing.osrmv1({
      serviceUrl: "https://router.project-osrm.org/route/v1",
      profile: "foot",
    }),
    show: false,
    addWaypoints: false,
    routeWhileDragging: false,
    fitSelectedRoutes: false,
    showAlternatives: false,
    createMarker: () => null,
  }).addTo(map);

  routeControl.on("routesfound", async (e) => {
  const r = e.routes?.[0];
  if (!r) return;
  const distKm = (r.summary.totalDistance / 1000);
  const timeMin = (r.summary.totalTime / 60);
  $("#kpiRoute").textContent = `${formatKm(distKm)} km Â· ì•½ ${Math.round(timeMin)}ë¶„`;

  // Auto-tune: keep OSRM route length close to selected km (within tolerance)
  const tol = Math.max(0.35, desiredKm * 0.07); // ~7% or at least 350m
  const now = Date.now();
  if (now - lastRouteTry > 900) { // avoid infinite loops
    if (Math.abs(distKm - desiredKm) > tol) {
      lastRouteTry = now;
      // If too short, increase detour; if too long, reduce detour
      if (distKm < desiredKm) detourScale = Math.min(3.2, detourScale * 1.35);
      else detourScale = Math.max(0.55, detourScale * 0.78);

      // Rebuild (up to 4 attempts per selection)
      window.__tuneCount = (window.__tuneCount || 0) + 1;
      if (window.__tuneCount <= 4) {
        toast("ê±°ë¦¬ ë³´ì •", `ì„ íƒ ${desiredKm}kmì— ë§ì¶”ëŠ” ì¤‘â€¦ (${distKm.toFixed(1)}km)`);
        buildRoute(true);
        return;
      }
    }
  }

  // Tuning done for this route
  window.__tuneCount = 0;

  try{
    const coords = r.coordinates || [];
    const stats = await computeRouteStats(coords);
    showRouteSummaryBox(coords, stats);
  }catch(err){
    const coords = r.coordinates || [];
    showRouteSummaryBox(coords, { distKm });
  }
});

routeControl.on("routingerror", () => {
  $("#kpiRoute").textContent = "ë£¨íŠ¸ ê³„ì‚° ì‹¤íŒ¨";
  clearRouteSummaryBox();
});

  routeControl.on("routingerror", () => {
    $("#kpiRoute").textContent = "ë£¨íŠ¸ ê³„ì‚° ì‹¤íŒ¨";
    clearRouteSummaryBox();
  });
}

// ------- GPS Tracking -------
function canGeo() {
  return !!navigator.geolocation;
}

function startTracking() {
  if (!canGeo()) {
    toast("ì§€ì› ë¶ˆê°€", "ì´ ë¸Œë¼ìš°ì €ëŠ” ìœ„ì¹˜ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    return;
  }
  if (tracking) return;

  tracking = true;
  paused = false;
  startTs = Date.now();
  elapsedSec = 0;

  lastFix = null;
  distanceM = 0;
  trackLatLngs = [];
  trackLine.setLatLngs(trackLatLngs);

  $("#btnStart").disabled = true;
  $("#btnPause").disabled = false;
  $("#btnStop").disabled = false;
  $("#btnPause").textContent = "ì¼ì‹œì •ì§€";
  $("#kpiState").textContent = "ëŸ¬ë‹ ì¤‘";

  toast("ëŸ¬ë‹ ì‹œì‘", "GPS íŠ¸ë˜í‚¹ì„ ì‹œì‘í•©ë‹ˆë‹¤.");

  timerId = setInterval(() => {
    if (!tracking || paused) return;
    elapsedSec += 1;
    updateKPIs();
  }, 1000);

  watchId = navigator.geolocation.watchPosition(onFix, onGeoErr, {
    enableHighAccuracy: true,
    timeout: 12000,
    maximumAge: 800,
  });
}

function pauseTracking() {
  if (!tracking) return;
  paused = !paused;
  $("#btnPause").textContent = paused ? "ì¬ê°œ" : "ì¼ì‹œì •ì§€";
  $("#kpiState").textContent = paused ? "ì¼ì‹œì •ì§€" : "ëŸ¬ë‹ ì¤‘";
  toast(paused ? "ì¼ì‹œì •ì§€" : "ì¬ê°œ", paused ? "ì ì‹œ ì‰¬ì–´ê°€ë„ ë©ë‹ˆë‹¤." : "ë‹¤ì‹œ ë‹¬ë ¤ë³¼ê¹Œìš”?");
}

function stopTracking() {
  if (!tracking) return;

  // finalize
  const km = distanceM / 1000;
  const level = LEVELS[selectedLevel];
  const ok = (selectedLevel === "lv3") ? (km >= level.min) : (km >= level.min && km <= level.max);

  tracking = false;
  paused = false;

  if (timerId) clearInterval(timerId);
  timerId = null;

  if (watchId != null) navigator.geolocation.clearWatch(watchId);
  watchId = null;

  $("#btnStart").disabled = false;
  $("#btnPause").disabled = true;
  $("#btnStop").disabled = true;
  $("#kpiState").textContent = "ëŒ€ê¸°";

  const result = ok ? "ì™„ì£¼ ì„±ê³µ ğŸ‰" : "ì™„ì£¼ ë¯¸ë‹¬";
  const hint = ok
    ? `ê±°ë¦¬ ${formatKm(km)}km Â· ${LEVELS[selectedLevel].rewardHint}`
    : `ê±°ë¦¬ ${formatKm(km)}km (ëª©í‘œ ${level.min}~${level.max}km)`;

  toast(result, hint);

  // keep line on map; user can clear manually
  updateKPIs(true);
}

function onFix(pos) {
  if (!tracking || paused) {
    // still update current position for route estimation
    const { latitude: lat, longitude: lng, accuracy: acc } = pos.coords;
    lastFix = { lat, lng, ts: pos.timestamp || Date.now(), acc };
    updateUserMarker(lat, lng);
    return;
  }

  const { latitude: lat, longitude: lng, accuracy: acc, speed } = pos.coords;
  const ts = pos.timestamp || Date.now();

  // Update pills
  $("#kpiAcc").textContent = acc ? `${Math.round(acc)}m` : "--";
  const spdKmh = (typeof speed === "number" && !Number.isNaN(speed)) ? speed * 3.6 : null;
  $("#kpiSpeed").textContent = spdKmh ? `${spdKmh.toFixed(1)} km/h` : "--";

  // Distance calc
  const cur = { lat, lng, ts, acc };

  if (lastFix) {
    const dt = (ts - lastFix.ts) / 1000;
    const dM = haversine(lastFix.lat, lastFix.lng, lat, lng);

    // jitter filter
    if (dM >= JITTER_M && dt > 0) {
      const segSpeedKmh = (dM / dt) * 3.6;

      // simple anti-cheat
      if (segSpeedKmh <= SPEED_CHEAT_KMH) {
        distanceM += dM;
        trackLatLngs.push([lat, lng]);
        trackLine.setLatLngs(trackLatLngs);

        // smooth camera when running
        if ($("#toggleFollow").dataset.on === "1") {
          map.setView([lat, lng], map.getZoom(), { animate: true });
        }
      }
    }
  } else {
    trackLatLngs.push([lat, lng]);
    trackLine.setLatLngs(trackLatLngs);
    // build route after first fix
    buildRoute(true);
  }

  lastFix = cur;
  updateUserMarker(lat, lng);

  // update route occasionally
  if (elapsedSec % 8 === 0) buildRoute(true);

  updateKPIs();
}

function onGeoErr(err) {
  toast("GPS ì˜¤ë¥˜", "ìœ„ì¹˜ ê¶Œí•œì„ í—ˆìš©í–ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”. (https ë˜ëŠ” localhost í•„ìš”)");
  $("#kpiAcc").textContent = "â€”";
  $("#kpiSpeed").textContent = "â€”";
}

function updateKPIs(final = false) {
  const km = distanceM / 1000;
  $("#kpiDist").textContent = `${formatKm(km)} km`;
  $("#kpiTime").textContent = `${formatTime(elapsedSec)}`;
  $("#kpiPace").textContent = pace(elapsedSec, km);

  const lvl = LEVELS[selectedLevel];
  const progress = (selectedLevel === "lv3")
    ? Math.min(1, km / lvl.min)
    : Math.min(1, km / lvl.max);

  $("#kpiGoal").textContent =
    selectedLevel === "lv3"
      ? `${lvl.min}km+`
      : `${lvl.min}~${lvl.max}km`;

  $("#kpiProgress").textContent = `${Math.round(progress * 100)}%`;

  if (final) {
    // no-op; keep final display
  }
}


async function togglePOI() {
  poiOn = !poiOn;
  $("#chipPoi").classList.toggle("on", poiOn);

  if (!poiOn) {
    clearPOI();
    toast("ì‹ë‹¹ í‘œì‹œ", "ì£¼ë³€ ì‹ë‹¹ í‘œì‹œë¥¼ ë”.");
    return;
  }

  if (!lastFix) {
    toast("ì‹ë‹¹ í‘œì‹œ", "ë‚´ ìœ„ì¹˜ë¥¼ ë¨¼ì € ì¡ì•„ì£¼ì„¸ìš”. (ğŸ“ ë²„íŠ¼)");
    poiOn = false;
    $("#chipPoi").classList.remove("on");
    return;
  }

  await refreshPOI();
}

function clearPOI() {
  if (poiLayer) {
    try { map.removeLayer(poiLayer); } catch(e){}
    poiLayer = null;
  }
  poiMarkers = [];
}

async function refreshPOI() {
  if (!poiOn) return;
  if (!lastFix) return;

  const lat = lastFix.lat;
  const lng = lastFix.lng;
  const radius = 1200;

  // Optional: if search input looks like a food keyword (not a store name filter),
  // you can pass it as query by prefixing with "@" (e.g. @ì¹˜í‚¨)
  const raw = ($("#searchInput").value || "").trim();
  let query = "";
  if (raw.startsWith("@")) query = raw.slice(1).trim();

  const qs = new URLSearchParams({ lat: String(lat), lng: String(lng), radius: String(radius) });
  if (query) qs.set("query", query);

  try {
    const r = await fetch(`/api/kakao/nearby?${qs.toString()}`);
    const j = await r.json();

    if (!r.ok) {
      toast("ì‹ë‹¹ í‘œì‹œ ì‹¤íŒ¨", j?.hint ? j.hint : "ì„œë²„ ì„¤ì •(KAKAO_REST_KEY) ë˜ëŠ” ì¿¼í„°ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.");
      return;
    }

    clearPOI();
    poiLayer = L.layerGroup().addTo(map);

    (j.places || []).forEach(p => {
      const m = L.circleMarker([p.lat, p.lng], {
        radius: 7,
        color: "#0b1220",
        weight: 2,
        fillColor: "#FF4F00", // í¬ì¸íŠ¸ ì»¬ëŸ¬(ìŒì‹ì )
        fillOpacity: 0.95
      }).addTo(poiLayer);

      const dist = (p.distanceM != null) ? `${p.distanceM}m` : "";
      const addr = p.roadAddress || p.address || "";
      const link = p.placeUrl ? `<a href="${p.placeUrl}" target="_blank" rel="noreferrer">ì¹´ì¹´ì˜¤ì—ì„œ ë³´ê¸°</a>` : "";
      m.bindPopup(`<b>ğŸ´ ${p.name}</b><br/>${dist}<br/>${addr}<br/>${link}`);
      poiMarkers.push(m);
    });

    toast("ì‹ë‹¹ í‘œì‹œ", query ? `ì£¼ë³€ '${query}' ê²°ê³¼ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.` : "ì£¼ë³€ ìŒì‹ì (ì•½ 1.2km) í‘œì‹œ ì¤‘");
  } catch (e) {
    toast("ì‹ë‹¹ í‘œì‹œ ì‹¤íŒ¨", "ë„¤íŠ¸ì›Œí¬/ì„œë²„ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.");
  }
}


// ------- Controls -------
function bindControls() {
  $("#btnStart").addEventListener("click", startTracking);
  $("#btnPause").addEventListener("click", pauseTracking);
  $("#btnStop").addEventListener("click", stopTracking);

  $("#fabLocate").addEventListener("click", locateOnce);
  $("#fabGoal").addEventListener("click", () => {
    focusGoal();
  });
  $("#fabClear").addEventListener("click", () => {
    trackLatLngs = [];
    distanceM = 0;
    elapsedSec = 0;
    lastFix = lastFix; // keep
    trackLine.setLatLngs([]);
    updateKPIs();
    toast("íŠ¸ë™ ì´ˆê¸°í™”", "ëŸ¬ë‹ ì„ /ê±°ë¦¬/ì‹œê°„ì„ ì´ˆê¸°í™”í–ˆìŠµë‹ˆë‹¤.");
  });

  $("#toggleFollow").addEventListener("click", () => {
    const on = $("#toggleFollow").dataset.on === "1";
    $("#toggleFollow").dataset.on = on ? "0" : "1";
    $("#toggleFollow").textContent = on ? "ğŸ‘ï¸ ë”°ë¼ê°€ê¸° OFF" : "ğŸ‘ï¸ ë”°ë¼ê°€ê¸° ON";
    toast("ì¹´ë©”ë¼", on ? "ë‚´ ìœ„ì¹˜ ë”°ë¼ê°€ê¸° OFF" : "ë‚´ ìœ„ì¹˜ ë”°ë¼ê°€ê¸° ON");
  });

  $("#btnReRoute").addEventListener("click", () => {
    if (!lastFix) return toast("ë£¨íŠ¸", "ë‚´ ìœ„ì¹˜ ìˆ˜ì‹  í›„ ê°€ëŠ¥í•©ë‹ˆë‹¤.");
    buildRoute();
    toast("ì¶”ì²œ ë£¨íŠ¸", "í˜„ì¬ ìœ„ì¹˜ â†’ ëª©ì ì§€ ë£¨íŠ¸ë¥¼ ê°±ì‹ í–ˆìŠµë‹ˆë‹¤.");
  });
}

function locateOnce() {
  if (!canGeo()) return toast("ì§€ì› ë¶ˆê°€", "ì´ ë¸Œë¼ìš°ì €ëŠ” ìœ„ì¹˜ ê¸°ëŠ¥ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
  navigator.geolocation.getCurrentPosition(
    (pos) => {
      const { latitude: lat, longitude: lng, accuracy: acc } = pos.coords;
      lastFix = { lat, lng, ts: pos.timestamp || Date.now(), acc };
      updateUserMarker(lat, lng);
      map.setView([lat, lng], 15, { animate: true });
      buildRoute(true);
      toast("ë‚´ ìœ„ì¹˜", `ì •í™•ë„ ì•½ ${Math.round(acc)}m`);
    },
    () => toast("ê¶Œí•œ í•„ìš”", "ìœ„ì¹˜ ê¶Œí•œì„ í—ˆìš©í•´ì£¼ì„¸ìš”. (https ë˜ëŠ” localhost)"),
    { enableHighAccuracy: true, timeout: 12000, maximumAge: 2000 }
  );
}

// ------- Init -------
function init() {
  // Top chips initial
  $("#chipLv1").classList.add("on");
  bindTopChips();
  bindSearch();

  renderLevels();
  renderStoreList(STORES);
  updateHeaderBadges();

  // Map init
  initMap();

  // Buttons
  bindControls();

  // Initial KPIs
  $("#kpiRoute").textContent = "ë‚´ ìœ„ì¹˜ ìˆ˜ì‹  í›„ í‘œì‹œ";
  $("#kpiState").textContent = "ëŒ€ê¸°";
  $("#kpiAcc").textContent = "--";
  $("#kpiSpeed").textContent = "--";
  $("#kpiGoal").textContent = `${LEVELS[selectedLevel].min}~${LEVELS[selectedLevel].max}km`;
  $("#kpiProgress").textContent = "0%";
  $("#kpiDist").textContent = "0.00 km";
  $("#kpiTime").textContent = "0:00";
  $("#kpiPace").textContent = "--";

  // Friendly prompt (ì—„ë§ˆì˜ ì§€ë„ ëŠë‚Œ: ì•ˆë‚´ í†¤)
  setTimeout(() => {
    toast("ì‹œì‘ ì•ˆë‚´", "ì˜¤ë¥¸ìª½ ìƒë‹¨ ğŸ“ ë²„íŠ¼ìœ¼ë¡œ ë‚´ ìœ„ì¹˜ë¥¼ ë¨¼ì € ì¡ê³ , í•˜ë‹¨ì—ì„œ ëŸ¬ë‹ ì‹œì‘í•˜ì„¸ìš”.");
  }, 600);
}

window.addEventListener("DOMContentLoaded", () => {
  // Load routing machine script after Leaflet exists
  // It's included in HTML, so safe.
  init();
});

</script>
</body>
</html>
